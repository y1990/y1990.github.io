{"pages":[],"posts":[{"title":"属性（Property）","text":"介绍属性是封装在对象里的数据，最终还是通过实例变量来实现，它提供了一种简介的抽象机制。在OC中，存取方法有着严格的命名规范，编译器会自动为属性创建出存取方法，用以访问给定类型中具有给定名称的变量。 @property用 @property 语法创建属性： @interface Person : NSObject @property NSString *name; @end 访问属性，使用“点语法”：效果与直接调用存取方法相同。 Person *aPerson = [Person new]; aPerson.name = @\"Bob\"; // 等同于 [aPerson setName: @\"Bob\"]; NSString *name = aPerson.name; // 等同于 NSString *name = [aPerson name]; 编译器为属性自动编写存取方法的过程，叫做“自动合成”，这个过程是由编译器在编译期执行，编辑器里是看不到这些“合成方法”的代码。另外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。如上面的 _name。 @synthesize通过 @synthesize 语法指定实例变量的名字，实例变量不再使用默认的名字： @implementation Person @synthesize name = _myName; @end @dynamic使用 @dynamic 关键字，编译器不会自动创建属性所用的实例变量，也不会合成属性的存取方法。 注意：访问属性时，编译器发现没有定义存取方法，不会报错，它会认为这些方法能在运行期找到。 属性特质属性的特质设定会影响编译器所生成的存取方法。 原子性 atomic（默认），由编译器所合成的方法会通过锁定机制确保其原子性。使用同步锁操作开销较大，会带来性能问题。 nonatomic 非原子性，一般都会把属性特质声明为非原子性，因为原子的并不能保证线程安全。比如，一个线程连续多次读取属性的值，另外一个线程同时修改该值，即便声明为 atomic，也还是会读到不同的值。 读写权限 readonly（只读），属性仅拥有获取方法。 readwrite（读写），默认特质，属性拥有存取方法，即 “获取方法”(getter) 和 “设置方法”(setter)。 内存管理语义内存管理语义的特质仅会影响 “设置方法”。 assign（MRC下默认），“设置方法” 只会针对基本数据类型的简单赋值操作。在 MRC 下，也会用来管理 delegate 防止对象间的循环引用，但必须在 dealloc 方法中对 delegate 赋值 nil，否则 assign 属性指向的对象废弃后，属性不会自动设置为 nil，这样属性就变成了野指针，再去访问属性，容易造成崩溃。 strong（ARC下默认），此特质表明该属性定义了一种 “拥有关系”，为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。 1234567- (void)setName:(NSString *)name { if (_name != name) { [name retain]; // 保留新值 [_name release]; // 释放旧值 _name = name; // 将新值设置上去 }} weak 此特质表明该属性定义了一种 “非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似，然而属性所指的对象废弃时，属性值也会被设置为 nil。 12345- (void)setName:(NSString *)name { if (_name != name) { _name = name; }} unsafe_unretained 和 assign 类似，但它适用于 “对象类型”，表达了一种 “非拥有关系”，当目标对象遭到摧毁是，属性值不会自动清空。 copy 与 strong 类似，然而设置方法并不保留新值，而是将其 “拷贝”。 1234567- (void)setName:(NSString *)name { if (_name != name) { NSString *temp = [name copy]; [_name release]; _name = temp; }} 方法名 getter=&lt;name&gt; 指定 “获取方法” 的方法名。 1@property (nonatomic, getter=isOn) BOOL on; setter=&lt;name&gt; 指定 “设置方法” 的方法名。 访问实例变量一般地，在对象之外访问实例变量时，总是通过属性来做，然而在对象内部访问实例变量时，应该怎么做？这两者的区别是什么？ 直接访问实例变量，不会经过 Objective-C 的 “方法派发” 步骤，编译器会直接访问保存对象实例变量的那块内存，所以访问速度更快。 直接访问实例变量时，不会调用 “设置方法”，这就绕过了相关属性所定义的 “内存管理语义”。 直接访问实例变量，不会触发 KVO。 通过属性访问实例变量，有助于排查与之相关的错误，因为可以给 getter 和 setter 方法中增加断点。 了解了这些区别之后，我们可以采用折中方案：在写入实例变量时，通过其 “设置方法” 来做，而在读书实例变量时，则直接访问。这样既能提高读取操作的速度，又能控制对属性的写入操作以及确保相关属性的 “内存管理语义”。 123self.name = @\"Pipefish\";NSLog(@\"name is %@.\", _name); 当然凡事不是绝对的，比如有一些特殊情况，就需要注意： 1、在初始化方法和 dealloc 方法中，应该直接通过实例变量来读写数据。因为子类可能会重写属性的 “设置方法”，此时父类通过属性操作来写入，将会调用子类的 “设置方法”。 123456- (id)initWithName:(NSString *)name { if (self = [super init]) { _name = name; } return self;} 2、在使用 “惰性初始化技术”（懒加载）配置某份数据时，需要通过属性来读取数据。 123456- (Person *)someone { if (!_someone) { _someone = Person.new; } return _someone;}","link":"/2021/05/10/%E5%B1%9E%E6%80%A7%EF%BC%88Property%EF%BC%89/"}],"tags":[],"categories":[]}